"""
ID посылки - https://contest.yandex.ru/contest/25597/run-report/142343664/

Задача - Найти расстояние Левенштейна для предложенной пары строк.

Примечание: Пусть w1 и w2 пара строк, такая, что w1 нужно превратить в w2.

--- Принцип работы ---
- Итоговое расстояние Левенштейна для пары строк получается через рассмотрение
расстояния между парами строк меньшего размера, в связи с этим используется обратная динамика,
где строки начинают наращиваться с конца.
- Если символы равны, то расстояние равно расстоянию для предыдущей пары (оба указателя вправо)
- Если символы не равны, то появляются 3 возможных ситуации:
    - Когда мы удаляем элемент, указатель сдвигается вправо для w1
    - Когда мы вставляем элемент, указатель сдвигается вправо для w2
    - Когда мы заменяем элемент, оба указателя сдвигаются вправо
- Каждый случай ведет к разным парам строк, и для каждой из них уже посчитано расстояние Левенштейна,
  поэтому исходная строка принимает минимальное расстояние из 3-х случаев, плюс одна операция.
- В конце алгоритм посчитает расстояние Левенштейна для исходной пары.

--- Доказательства корректности ---
- Для решения задачи используется двумерная динамики, которая считается снизу вверх.
- Состояние динамики dp[i][j] обозначает редакционное расстояние для суффиксов двух пар строк, которые
начинаются с i и j индекса соответственно.
- Переход динамики зависит от возможных случаев:
    - Если S[i] == T[j], то dp[i][j] = dp[i - 1][j + 1]
    - Если S[i] != T[j], то dp[i][j] = min(dp[i - 1][j + 1], dp[i - 1][j], dp[i][j + 1]) + 1, где
        - dp[i - 1][j + 1] - когда мы заменяем элемент
        - dp[i - 1][j] - когда мы удаляем элемент
        - dp[i][j + 1] - когда мы вставляем элемент
        - +1 - стоимость операции
- По выполнению работы алгоритма, результат будет храниться в dp[0][0]
Поскольку мы перебираем все возможные пары строк, и для каждой обрабатываем все возможные ситации,
алгоритм не пропускает минимальное редакционное расстояние. Таким образом алгоритм корректен. ■

--- Временная сложность ---
Алгоритм, для каждого символа одной строки, перебирает все возможные символы другой,
=> Временная сложность = O(N * M), где N, M - длины w1 и w2 соответственно.

--- Пространственная сложность ---
Данный алгоритм является модификацией, в силу того, что хранит только предыдущую "строчку",
а не всю таблицу состояний динамики.
=> Пространственная сложность = O(M), где M - длина строки, которую мы должны получить.
"""

import sys


def solution(s, t):
    l_s, l_t = len(s), len(t)
    curr = [float("inf") for _ in range(l_t + 1)]
    prev = [j for j in range(l_t, -1, -1)]

    for i in range(l_s - 1, -1, -1):
        curr[-1] = l_s - i
        for j in range(l_t - 1, -1, -1):
            if s[i] == t[j]:
                curr[j] = prev[j + 1]
            else:
                curr[j] = 1 + min(prev[j], curr[j + 1], prev[j + 1])
        prev = curr.copy()
        curr = [float("inf") for _ in range(l_t + 1)]

    return prev[0]


def main():
    s = sys.stdin.readline().rstrip()
    t = sys.stdin.readline().rstrip()
    sys.stdout.write(str(solution(s, t)))


if __name__ == "__main__":
    main()
