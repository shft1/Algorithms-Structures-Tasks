"""
ID посылки - https://contest.yandex.ru/contest/24414/run-report/140318057/

                                        Реализация хеш-таблицы
Поддерживаемые методы:
- put key value —– добавление пары ключ-значение. Если заданный ключ уже есть в таблице, то соответствующее ему значение обновляется.
- get key –— получение значения по ключу. Если ключа нет в таблице, то выводится «None». Иначе выводится найденное значение.
- delete key –— удаление ключа из таблицы. Если такого ключа нет, то вывести «None», иначе выводится хранимое по данному ключу значение и удаляется ключ.

Характеристики хеш-таблицы:
- Вычисление корзины происходит через метод деления
- Разрешение коллизий происходит через метод открытой адресации со стратегией пробирования - двойное хеширование.
- Все операции, в среднем, выполняются за O(1)

--- Принцип работы ---
1. На вход поступает команда для хеш-таблицы
2. В зависимости от команды мы вызываем тот или иной метод
3. Для каждого метода запускается пробирование, предварительно для этого вычисляется хеш ключа от hash1_func и hash2_func хеш-функций
4. Возвращается результат пробирования
(результат пробирования зависит от конкретной команды хеш-таблицы)

--- Доказательства корректности ---
Докажем корректность работы хеш-таблицы через свойства построения хеш-функций:
1. Детерминизм (Для одного и того же ключа функция всегда должна возвращать одинаковое значение)
Так как ключи - целые числа, то одна и та же операция с одним и тем же числом всегда дает один и тот же ответ.
2. Эффективность (Хеш-функция должна вычисляться достаточно быстро)
Хеш целого числа - это само число, поэтому операция вычисления хеша - O(1)
Вычисление номера корзины для данного хеша - взятие остатка от деления хеша на размер хеш-таблицы
Эти операции выполняются достаточно быстро, поэтому такая хеш-функция эффективна
3. Ограниченность (Результат вычисления функции должен принадлежать определённому диапазону, который соответствует размеру хеш-таблицы)
Поскольку мы берем остаток от деления хеша на размер хеш-таблицы, то номер корзины будет принадлежать диапазону - [0, M-1]
4. Равномерность (Данные должны быть распределены по хеш-таблице равномерно)
Поскольку в качестве размера таблицы берется простое число, то вероятность получения одного и то же остатка для двух разных ключей будет минимальна,
ведь с делителем имеется только один нетривиальный (!=1) остаток - само число корзин.
Следовательно данные распределяются равномерно
-> Из доказательств соответствия этим свойствам следует, что хеш-таблица реализована корректно.

--- Временная сложность ---
(данная сложность не будет учитывать кол-во итераций для обработки команд и вывода ответов)
Временная сложность работы хеш-таблицы оценивается в среднем случае, которая во многом зависит от коэффициента a - коэффициента заполнения хеш-таблицы.
Поэтому в среднем сложность равна O(1 + a), но поскольку коэффициент a поддерживается в статичном состоянии, то среднюю временную сложность
можно асимптотически приравнять к O(1).
-> Итоговая временная сложность - O(1)

--- Пространственная сложность ---
Размер хеш-таблицы также зависит от коэффициента заполнения а, поскольку таблица не должна поддерживать рехеширование и масштабирование,
размер таблицы статичен и выбирается с учетом коэффициента a = 2/3 и N - максимальным кол-вом ключей для нее = 10**5
-> Итоговая пространственная сложность - O(N / a).
"""

import sys


class HashTable:
    def __init__(self, max_el):
        self.size = max_el * 2 + 3
        self.hash_map = [None] * self.size
        self.DELETED = "DELETED"

    def hash2_func(self, key):
        return key % (self.size - 1) + 1

    def hash1_func(self, key):
        return key % self.size

    def put(self, key, value):
        b1_idx = self.hash1_func(key)
        b2_idx = self.hash2_func(key)
        for i in range(self.size):
            bucket_idx = (b1_idx + (i * b2_idx) % self.size) % self.size
            bucket = self.hash_map[bucket_idx]
            if bucket is None or bucket[0] is self.DELETED or bucket[0] == key:
                self.hash_map[bucket_idx] = (key, value)
                return
        raise RuntimeError("Таблица переполнена!")

    def get(self, key):
        b1_idx = self.hash1_func(key)
        b2_idx = self.hash2_func(key)
        for i in range(self.size):
            bucket = self.hash_map[
                (b1_idx + (i * b2_idx) % self.size) % self.size
            ]
            if bucket is None:
                raise KeyError(None)
            k, v = bucket
            if key == k:
                return v
        raise RuntimeError("Таблица переполнена!")

    def delete(self, key):
        b1_idx = self.hash1_func(key)
        b2_idx = self.hash2_func(key)
        for i in range(self.size):
            bucket_idx = (b1_idx + (i * b2_idx) % self.size) % self.size
            bucket = self.hash_map[bucket_idx]
            if bucket is None:
                raise KeyError(None)
            k, v = bucket
            if key == k:
                self.hash_map[bucket_idx] = (self.DELETED, self.DELETED)
                return v
        raise RuntimeError("Таблица переполнена!")


def solution(n):
    h_map = HashTable(max_el=10**5)
    res = []
    for _ in range(n):
        cmd = sys.stdin.readline().rstrip().split()
        try:
            if cmd[0] == "get":
                res.append(h_map.get(key=int(cmd[1])))
            elif cmd[0] == "put":
                h_map.put(key=int(cmd[1]), value=int(cmd[2]))
            elif cmd[0] == "delete":
                res.append(h_map.delete(key=int(cmd[1])))
            else:
                raise RuntimeError("Такой команды не существует!")
        except KeyError as e:
            res.append(e)
        except RuntimeError as e:
            print(f"Ошибка в работе с хеш-таблицой: {e}")
    return res


def main():
    n = int(sys.stdin.readline().rstrip())
    res = solution(n)
    for ans in map(str, res):
        sys.stdout.write(ans + "\n")


if __name__ == "__main__":
    main()
