"""
ID посылки - https://contest.yandex.ru/contest/23815/run-report/139997714/

--- Принцип работы ---

Алгоритм in-place quick sort - модификация обычной quick sort, которая не использует дополнительную память
для хранения промежуточных данных.

Как и в случае обычной быстрой сортировки, которая использует доп.память, мы выбираем
опорный элемент (pivod) и далее нам нужно переупорядочить массив на месте, сделав in-place шаг.

- Зависит от порядка сортировки -
    - если мы сортируем по возрастанию, то делаем так, чтобы сначала шли элементы,
      не превосходящие опорного, а затем —– большие опорного.
    - если мы сортируем по убыванию, то делаем так, чтобы сначала шли элементы,
      не меньшие опорного, а затем —– меньшие.

- Как реализуется in-place шаг для сортировки по убыванию -
    - заводим два указателя left и right которые изначально будут указывать на левый и правый концы отрезка соответственно.
    - затем будем двигать левый указатель вправо до тех пор, пока он указывает на элемент, больший либо равный опорному.
    - аналогично двигаем правый указатель влево, пока он стоит на элементе, меньше опорного.
    В итоге окажется, что левее от left все элементы точно принадлежат первой группе, а правее от right — второй.
    - элементы, на которых стоят указатели, нарушают порядок. Поменяем их местами и продвинем указатели на следующие элементы.
    - будем повторять это действие до тех пор, пока left не станет больше right.

После того, как мы переупорядочили массив на месте, мы рекурсивно применяем этот алгоритм на получившихся двух частях.
Для получения частей, из функции упорядочивания, возвращаются индексы конца левой части и начала правой.

К задаче:
Для данной задачи мы используем алгоритм in-place quick sort с сортировкой элементов по убыванию.
Сортировка происходит по 3 показателям: 1 элемент по возрастанию, 0 и 2 по убыванию.
Поскольку лексиграфическая сортировка требует сортировки одном порядке, то нам выгодно сортировать по убыванию,
а 2 элемент заменить на отрицательный, тогда наибольший элемент будет "всплывать" к концу массива.
В итоге, ключом сортировки для элемента будет - [-элемент[1], элемент[2], элемент[3]]


--- Доказательства корректности ---

Данный алгоритм работает по принципу quick sort, а поэтому он корректен.

--- Временная сложность ---

На каждом уровне рекурсии происходит O(n) операций сравнения.

Если опорный элемент был выбран неудачно, мы имеем высоту стека вызовов равную O(n).
Итого, в худшем случае, мы имеем временную сложность равную: O(n) * O(n) = O(n^2)

Удачный выбор опорного элемента - это есть и лучший, и средний случай, когда массив делится пополам.
Тогда, высота стека вызовов равняется O(logn).
Итого, в среднем-лучшем случае, мы имеем временную сложность равную: O(n) * O(logn) = O(nlogn)


--- Пространственная сложность ---

Данный алгоритм не использует дополнительную память на каждом уровне рекурсии.
Следовательно, пространственная сложность складывается только из высоты стека вызовов рекурсии.

Если опорный элемент был выбран неудачно, мы имеем высоту стека вызовов равную O(n).
Итого, в худшем случае, мы имеем пространственную сложность равную O(n).

Удачный выбор опорного элемента - это есть и лучший, и средний случай, когда массив делится пополам.
Тогда, высота стека вызовов равняется O(logn).
Итого, в среднем-лучшем случае, мы имеем пространственную сложность равную: O(logn)
"""

import random
import sys


def key(obj):
    return (-obj[1], obj[2], obj[0])


def partition(arr, lf, rg, pivot):
    lf_up, rg_dwn = lf, rg
    while lf_up <= rg_dwn:
        while key(arr[lf_up]) > key(pivot):
            lf_up += 1
        while key(arr[rg_dwn]) < key(pivot):
            rg_dwn -= 1
        if lf_up <= rg_dwn:
            arr[lf_up], arr[rg_dwn] = arr[rg_dwn], arr[lf_up]
            lf_up += 1
            rg_dwn -= 1
    return rg_dwn, lf_up


def in_place_qsort(arr, lf, rg):
    if lf >= rg:
        return
    pivot = arr[random.randrange(lf, rg + 1)]
    lf_up, rg_dwn = partition(arr, lf, rg, pivot)
    in_place_qsort(arr, lf, lf_up)
    in_place_qsort(arr, rg_dwn, rg)


def main():
    n = int(sys.stdin.readline().rstrip())
    arr = [sys.stdin.readline().rstrip().split() for _ in range(n)]
    for elmnt in arr:
        elmnt[1], elmnt[2] = int(elmnt[1]), int(elmnt[2])

    in_place_qsort(arr, 0, n - 1)

    res = "\n".join([arr[i][0] for i in range(n - 1, -1, -1)])
    sys.stdout.write(res + "\n")


if __name__ == "__main__":
    main()
