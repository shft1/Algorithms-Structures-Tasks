"""
ID посылки - https://contest.yandex.ru/contest/23815/run-report/139898737/

--- Принцип работы ---

Алгоритм in-place quick sort - модификация обычной quick sort, которая не использует дополнительную память
для хранения промежуточных данных.

Как и в случае обычной быстрой сортировки, которая использует доп.память, мы выбираем
опорный элемент (pivod) и далее нам нужно переупорядочить массив на месте, сделав in-place шаг.

- Зависит от порядка сортировки -
    - если мы сортируем по возрастанию, то делаем так, чтобы сначала шли элементы,
      не превосходящие опорного, а затем —– большие опорного.
    - если мы сортируем по убыванию, то делаем так, чтобы сначала шли элементы,
      не меньшие опорного, а затем —– меньшие.

- Как реализуется in-place шаг для сортировки по убыванию -
    - заводим два указателя left и right которые изначально будут указывать на левый и правый концы отрезка соответственно.
    - затем будем двигать левый указатель вправо до тех пор, пока он указывает на элемент, больший либо равный опорному.
    - аналогично двигаем правый указатель влево, пока он стоит на элементе, меньше опорного.
    В итоге окажется, что левее от left все элементы точно принадлежат первой группе, а правее от right — второй.
    - элементы, на которых стоят указатели, нарушают порядок. Поменяем их местами и продвинем указатели на следующие элементы.
    - будем повторять это действие до тех пор, пока left не станет больше right.

После того, как мы переупорядочили массив на месте, мы рекурсивно применяем этот алгоритм на получившихся двух частях.
Для получения частей, из функции упорядочивания, возвращаются индексы конца левой части и начала правой.

К задаче:
Для данной задачи мы используем алгоритм in-place quick sort с сортировкой элементов по убыванию.
Сортировка происходит по 3 показателям: 1 элемент по возрастанию, 0 и 2 по убыванию.
Поскольку лексиграфическая сортировка требует сортировки одном порядке, то нам выгодно сортировать по убыванию,
а 2 элемент заменить на отрицательный, тогда наибольший элемент будет "всплывать" к концу массива.
В итоге, ключом сортировки для элемента будет - [-элемент[1], элемент[2], элемент[3]]


--- Доказательства корректности ---

Данный алгоритм работает по принципу quick sort, а поэтому он корректен.

--- Временная сложность ---

Данный алгоритм работает, как и обычная быстрая сортировка, за O(nlogn).
Итоговая временная сложность - O(nlogn)

--- Пространственная сложность ---

Данный алгоритм не использует дополнительную память, сортирует массив на месте
Итоговая пространственная сложность - O(1)
"""

import random
import sys


def key(obj):
    return [-obj[1], obj[2], obj[0]]


def partition(arr, lf, rg, pivot):
    lf_up, rg_dwn = lf, rg
    while lf_up <= rg_dwn:
        while key(arr[lf_up]) > key(pivot):
            lf_up += 1
        while key(arr[rg_dwn]) < key(pivot):
            rg_dwn -= 1
        if lf_up <= rg_dwn:
            arr[lf_up], arr[rg_dwn] = arr[rg_dwn], arr[lf_up]
            lf_up += 1
            rg_dwn -= 1
    return rg_dwn, lf_up


def in_place_qsort(arr, lf, rg):
    if lf >= rg:
        return
    pivot = arr[random.randrange(lf, rg + 1)]
    lf_up, rg_dwn = partition(arr, lf, rg, pivot)
    in_place_qsort(arr, lf, lf_up)
    in_place_qsort(arr, rg_dwn, rg)


if __name__ == "__main__":
    n = int(sys.stdin.readline().rstrip())
    arr = [sys.stdin.readline().rstrip().split() for _ in range(n)]
    for elmnt in arr:
        elmnt[1], elmnt[2] = int(elmnt[1]), int(elmnt[2])

    in_place_qsort(arr, 0, n - 1)

    res = "\n".join([arr[i][0] for i in range(n - 1, -1, -1)])
    sys.stdout.write(res + "\n")
