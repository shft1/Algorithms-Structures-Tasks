"""
ID посылки - https://contest.yandex.ru/contest/25070/run-report/141529781/

Задача: Построить максимальное остовное дерево и вывести его вес.

Примечание: U - множество вершин, которые принадлежат остовному дереву

--- Принцип работы ---
> На каждом шаге работы алгоритма выбирается ребро с наибольшим весом,
которое соединяет вершину из множества U c вершиной, которая этому множеству не принадлежит.
> Алгоритм продолжает работу до тех пор, пока не будут обработаны все вершины.
> Алгоритм по шагам:
    0. Инициализируем MaxHeap и добавляем ребро, которое соединяется с любой вершиной графа
    1. Пока куча не пуста: Выбираем из кучи элемент, находящийся на вершине (максимальное ребро)
    2. Если вершина, куда ведет ребро, не посещена - добавляем ее в остов (мн-во U) и прибавляем вес ребра к весу дерева
    2.1 Иначе переходим к шагу 1
    3. Все смежные, с новой вершиной, ребра добавляем в приоритетную очередь
    4. Переходим к шагу 1
    5. Если кол-во вершин в остове равно кол-ву вершин графа - возвращаем вес максимального остовного дерева
    5.1 Иначе возвращаем сообщение об ошибке

--- Доказательства корректности ---
Доказательство было заимствовано с сайта - http://e-maxx.ru/algo/mst_prim

> Пусть граф G был связным, т.е. ответ существует. Обозначим через T остов, найденный алгоритмом Прима, а через S — минимальный остов.
Очевидно, что T действительно является остовом (т.е. поддеревом графа G). Покажем, что веса S и T совпадают.
Рассмотрим первый момент времени, когда в T происходило добавление ребра, не входящего в оптимальный остов S.
Обозначим это ребро через e, концы его — через a и b, а множество входящих на тот момент в остов вершин — через V (согласно алгоритму, a Э V, b !=Э V, либо наоборот).
В оптимальном остове S вершины a и b соединяются каким-то путём P; найдём в этом пути любое ребро g, один конец которого лежит в V, а другой — нет.
Поскольку алгоритм Прима выбрал ребро e вместо ребра g, то это значит, что вес ребра g больше либо равен весу ребра e.
Удалим теперь из S ребро g, и добавим ребро e. По только что сказанному, вес остова в результате не мог увеличиться (уменьшиться он тоже не мог, поскольку S было оптимальным).
Кроме того, S не перестало быть остовом (в том, что связность не нарушилась, нетрудно убедиться: мы замкнули путь P в цикл, и потом удалили из этого цикла одно ребро).
Итак, мы показали, что можно выбрать оптимальный остов S таким образом, что он будет включать ребро e.
Повторяя эту процедуру необходимое число раз, мы получаем, что можно выбрать оптимальный остов S так, чтобы он совпадал с T.
Следовательно, вес построенного алгоритмом Прима T минимален.
> Данное доказательство легко переделать в поиск максимального остова, поэтому для максимума данный алгоритм корректен.

--- Временная сложность ---
Данный алгоритм работает на основе двоичной кучи с поддержанием максимума.
1. Данная куча хранит, суммарно, V вершин и каждая из них будет извлечена один раз.
Сложность этого этапа - O(VlogV)
2. Для каждого ребра, в кучу, будет добавлена потенциальная вершина остовного дерева.
Сложность этого этапа - O(ElogV)
>> Итоговая временная сложность алгоритма: O(VlogV + ElogV) = O((V + E)logV)
> Для разреженного графа (E = V), итоговая сложность будет равна: O(ElogV)
> Для плотного графа (E = V^2), итоговая сложность будет равна: O(V^2logV)

--- Пространственная сложность ---
Данный алгоритм выделяет дополнительную память под хранение приоритетной очереди и множества вершин остова.
1. Хранение приоритетной очереди = O(V)
2. Хранение множества вершин остова = O(V)
> Итоговая пространственная сложность алгоритма (без учета хранения графа): O(V + V) = O(2V) = O(V)
> Итоговая пространственная сложность алгоритма (с учетом хранения графа через список смежности): O(V + E)
"""

import sys
from heapq import heappop, heappush


def create_adjacency_list(n, m):
    adj_lst = [set() for _ in range(n + 1)]
    for _ in range(m):
        v1, v2, weight = map(int, sys.stdin.readline().rstrip().split())
        adj_lst[v1].add((-weight, v2))
        adj_lst[v2].add((-weight, v1))
    return adj_lst


def max_spt(adj_lst, start_vertex=1):
    visited = set()
    heap = []
    heappush(heap, (0, start_vertex))
    max_weight = 0
    while heap:
        weight, to_v = heappop(heap)
        if to_v not in visited:
            visited.add(to_v)
            max_weight += weight
            for adj_edge in adj_lst[to_v]:
                heappush(heap, adj_edge)
    if len(visited) == len(adj_lst) - 1:
        return str(-max_weight)
    return "Oops! I did it again"


def main():
    n, m = map(int, sys.stdin.readline().rstrip().split())
    adj_lst = create_adjacency_list(n, m)
    weight_mx_spt = max_spt(adj_lst)
    sys.stdout.write(weight_mx_spt)


if __name__ == "__main__":
    main()
