"""
ID посылки - https://contest.yandex.ru/contest/25070/run-report/141593827/

Задача: По данной карте, вывести количество островов и размер самого большого

--- Принцип работы ---
Задачу поиска островов и размер самого большого можно переформулировать в терминах графа:
Найти кол-во компонент связности графа и максимальное число вершин в компоненте.
> Для поиска компонент связности будет использоваться поиск в глубину (DFS).
> Алгоритм по шагам:
    1. Выбираем очередную ячейку на карте
    2.1 Если ячейка - непосещенный остров, то запускаем DFS для новой компоненты связности,
    подсчитывая кол-во вершин в ней
    2.2 Иначе переходим к шагу 1
    3. После того, как все ячейки карты обработаны:
       возвращаем кол-во компонент связности (кол-во островов) и
       максимальное число вершин (размер острова) в компоненте

--- Доказательства корректности ---
Данный алгоритм корректно считает кол-во островов и находит площадь наибольшего их них, так как:
1. Для каждого непосещенного острова, алгоритм поиска в глубину посещает все связные острова и,
по ходу работы, считает площадь такого острова
2. Если вершина не выбрана, значит это "вода" или уже посещенный остров
3. Каждая ячейка обрабатывается один раз, из-за чего не происходит повторной обработки одной и той же позиции.

--- Временная сложность ---
Обработка каждой ячейки поля - O(n * m), так как асимптотически данная сложность является самой большой, следует:
> Итоговая временная сложность алгоритма - O(n * m)

--- Пространственная сложность ---
Хотя стек алгоритма поиска в глубину никогда не хранит все ячейки карты,
асимптотически мы все же можем указать пространственную сложность как O(n * m)
> Итоговая пространственная сложность алгоритма - O(n * m)
"""

import sys


def DFS(y, x, vectors, islands, n, m, card):
    area = 0
    stack = [(y, x)]
    while stack:
        point = stack.pop()
        py, px = point
        if card[py][px] == "#":
            area += 1
            card[py][px] = islands
            for vy, vx in vectors:
                neighbour = (py + vy, px + vx)
                ny, nx = neighbour
                if 0 <= ny < n and 0 <= nx < m and card[ny][nx] == "#":
                    stack.append(neighbour)
    return area


def solution(n, m, card):
    vectors = ((0, 1), (0, -1), (1, 0), (-1, 0))
    islands = 0
    mx_count_islands = 0
    for y in range(n):
        for x in range(m):
            if card[y][x] == "#":
                islands += 1
                area = DFS(y, x, vectors, islands, n, m, card)
                mx_count_islands = max(area, mx_count_islands)
    return islands, mx_count_islands


def main():
    n, m = map(int, sys.stdin.readline().rstrip().split())
    card = [list(sys.stdin.readline().rstrip()) for _ in range(n)]
    cnt_comp, mx_cnt_islnds = solution(n, m, card)
    sys.stdout.write(f"{cnt_comp} {mx_cnt_islnds}")


if __name__ == "__main__":
    main()
