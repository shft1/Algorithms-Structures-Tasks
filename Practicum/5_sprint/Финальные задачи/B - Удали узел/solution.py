"""
ID посылки - https://contest.yandex.ru/contest/24810/run-report/140567632/

Задача: Из бинарного дерева поиска требуется удалить узел по данному ключу так, чтобы после
удаления дерево оставалась бинарным деревом поиска.

Примечание:
Важно помнить, что если мы удаляем узел, который связывает какие-то поддеревья, то для того, чтобы
избежать распадания дерева на части, мы должны на место удалённой вершины поставить какую-ту другую вершину.

Если дерево является бинарным деревом поиска, то значение такой вершины должно быть:
1. Больше либо равно всем значениям в левом поддереве удаляемой вершины
2. Меньше либо равно всем значениям в правом поддереве удаляемой вершины
Такая вершина является либо:
1. Максимальным (самым правым) элементом левого поддерева
2. Минимальным (самым левым) элементом правого поддерева

--- Принцип работы ---
1. Благодаря свойству дерева поиска быстро находится узел на удаление или определяется, что его нет.
Если нужный узел не был найден, то дерево остается без изменений
Если нужный узел был найден и:
1. Он является листом, то он без проблем удаляется, на его место ставится None
2. Он не лист, значит связывает какие-то поддеревья, и тут рассматриваются следующие ситуации:

2.1 Если у него есть левое поддерево (по умолчанию берем кандидата как макс. элемент левого поддерева):
2.1.1 Если это поддерево не имеет правого ребенка, то ему прикрепляется правый ребенок удаленного узла и возвращается как узел, который встает на место удаленного
2.1.2 Если это поддерево имеет правого ребенка, то мы ищем самый правый элемент.
2.1.2.1 Если кандидат на замену не имеет детей, то его можно спокойно удалить и поставить на место удаленный вершины.
2.1.2.2 Если кандидат на замену имеет детей, то только левого, его мы присваиваем как правого ребенка для родителя кандидата и ставим на место удаленный вершины.

2.2 Если у него нет левого поддерева и есть правое:
2.2.1 Если это поддерево не имеет левого ребенка, то ему прикрепляется левый ребенок удаленного узла и возвращается как узел, который встает на место удаленного
2.2.2 Если это поддерево имеет правого ребенка, то мы ищем самый правый элемент.
2.2.2.1 Если кандидат на замену не имеет детей, то его можно спокойно удалить и поставить на место удаленный вершины.
2.2.2.2 Если кандидат на замену имеет детей, то только правого, его мы присваиваем как левого ребенка для родителя кандидата и ставим на место удаленный вершины.

--- Доказательства корректности ---
Для каждого поддерева может быть 3 разных случая удаления + случай для листа => 7 разных случаев при удалении вершины.
Стоит отметить, что 7 случаев покрывают все возможные ситуации при удалении узла бинарного дерева поиска с сохранением его свойств.
Следовательно, алгоритм учитывает все возможные ситуации и обеспечивает безопасное удаление узла в бинарном дереве поиска, поэтому он корректен.

--- Временная сложность ---
Поскольку нам не гарантируется сбалансированность бинарного дерева поиска, это означает,
что, в худшем случае, сложность удаления узла будет равна O(n), где n - кол-во элементов в дереве
---> Итоговая временная сложность алгоритма - O(n)

--- Пространственная сложность ---
Данный алгоритм потребляет дополнительную память только в качестве глубины стека вызовов рекурсии и, поскольку,
нам не гарантируется сбалансированность бинарного дерева поиска, это означает,
что, в худшем случае, для нахождения удаляемой вершины мы пройдем по всем элементам дерева,
то есть высота стека вызовов рекурсии составит O(n), где n - кол-во элементов в дереве
---> Итоговая пространственная сложность алгоритма - O(n)
"""

import os
from typing import Optional

LOCAL = os.environ.get("REMOTE_JUDGE", "false") != "true"

if LOCAL:

    class Node:
        def __init__(self, left=None, right=None, value=0):
            self.right = right
            self.left = left
            self.value = value
else:
    from node import Node


def rightmost_node(root):
    while root.right.right:
        root = root.right
    rep_node = root.right
    root.right = rep_node.left if rep_node.left else None
    return rep_node


def leftmost_node(root):
    while root.left.left:
        root = root.left
    rep_node = root.left
    root.left = rep_node.right if rep_node.right else None
    return rep_node


def replace_node(root):
    if root.left is None and root.right is None:
        return None
    if root.left:
        l_sib = root.left
        if l_sib.right is None:
            l_sib.right = root.right
            return l_sib
        new_node = rightmost_node(l_sib)
    else:
        r_sib = root.right
        if r_sib.left is None:
            r_sib.left = root.left
            return r_sib
        new_node = leftmost_node(r_sib)
    new_node.left = root.left
    new_node.right = root.right
    return new_node


def remove(root, key) -> Optional[Node]:
    if root is None:
        return root
    if key == root.value:
        return replace_node(root)
    if key > root.value:
        root.right = remove(root.right, key)
    elif key < root.value:
        root.left = remove(root.left, key)
    return root


def test():
    node1 = Node(None, None, 2)
    node2 = Node(node1, None, 3)
    node3 = Node(None, node2, 1)
    node4 = Node(None, None, 6)
    node5 = Node(node4, None, 8)
    node6 = Node(node5, None, 10)
    node7 = Node(node3, node6, 5)
    new_head = remove(node7, 10)
    assert new_head.value == 5
    assert new_head.right is node5
    assert new_head.right.value == 8


if __name__ == "__main__":
    test()
